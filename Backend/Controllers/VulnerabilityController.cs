//5️⃣ Controllers/VulnerabilityController.cs

/*<artifacts>
<artifact identifier="vulnerability-controller" type="application/vnd.ant.code" language="csharp" title="Controllers/VulnerabilityController.cs">
// SabaFone Security System Automation System (SSAS)
// Backend/Controllers/VulnerabilityController.cs
// وحدة التحكم في نقاط الضعف - شركة سبأفون
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using SabaFone.Backend.Data;
using SabaFone.Backend.Data.Vulnerabilities.Models;
using SabaFone.Backend.Services;
using SabaFone.Backend.Utils;
namespace SabaFone.Backend.Controllers
{
/// <summary>
/// وحدة التحكم في نقاط الضعف والثغرات الأمنية
/// </summary>
[ApiController]
[Route("api/[controller]")]
[Authorize(Roles = "Admin,SecurityAnalyst,VulnerabilityManager")]
[Produces("application/json")]
public class VulnerabilityController : ControllerBase
{
private readonly SsasDbContext _context;
private readonly ILogger<VulnerabilityController> _logger;
private readonly IVulnerabilityService _vulnerabilityService;
private readonly IScanningService _scanningService;
private readonly IPatchManagementService _patchService;
private readonly IAuditService _auditService;
private readonly INotificationService _notificationService;
public VulnerabilityController(
        SsasDbContext context,
        ILogger<VulnerabilityController> logger,
        IVulnerabilityService vulnerabilityService,
        IScanningService scanningService,
        IPatchManagementService patchService,
        IAuditService auditService,
        INotificationService notificationService)
    {
        _context = context;
        _logger = logger;
        _vulnerabilityService = vulnerabilityService;
        _scanningService = scanningService;
        _patchService = patchService;
        _auditService = auditService;
        _notificationService = notificationService;
    }
    
    #region Vulnerabilities
    
    /// <summary>
    /// الحصول على نقاط الضعف / Get Vulnerabilities
    /// </summary>
    [HttpGet("vulnerabilities")]
    public async Task<IActionResult> GetVulnerabilities(
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20,
        [FromQuery] VulnerabilitySeverity? severity = null,
        [FromQuery] VulnerabilityStatus? status = null,
        [FromQuery] string? cveId = null,
        [FromQuery] DateTime? startDate = null,
        [FromQuery] DateTime? endDate = null)
    {
        try
        {
            var query = _context.Vulnerabilities
                .Include(v => v.Patches)
                .Where(v => !v.IsDeleted);
            
            // Apply filters
            if (severity.HasValue)
                query = query.Where(v => v.Severity == severity.Value);
            
            if (status.HasValue)
                query = query.Where(v => v.Status == status.Value);
            
            if (!string.IsNullOrWhiteSpace(cveId))
                query = query.Where(v => v.CVEId != null && v.CVEId.Contains(cveId));
            
            if (startDate.HasValue)
                query = query.Where(v => v.DiscoveredAt >= startDate.Value);
            
            if (endDate.HasValue)
                query = query.Where(v => v.DiscoveredAt <= endDate.Value);
            
            // Get total count
            var totalCount = await query.CountAsync();
            
            // Apply pagination
            var vulnerabilities = await query
                .OrderByDescending(v => v.Severity)
                .ThenByDescending(v => v.DiscoveredAt)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .Select(v => new VulnerabilityDto
                {
                    VulnerabilityId = v.VulnerabilityId,
                    CVEId = v.CVEId,
                    Title = v.Title,
                    Description = v.Description,
                    Type = v.Type,
                    Severity = v.Severity,
                    Status = v.Status,
                    CVSSBaseScore = v.CVSSBaseScore,
                    CVSSVector = v.CVSSVector,
                    RiskLevel = v.RiskLevel,
                    IsExploitable = v.IsExploitable,
                    ExploitAvailable = v.ExploitAvailable,
                    ActivelyExploited = v.ActivelyExploited,
                    DiscoveredAt = v.DiscoveredAt,
                    AffectedAssetsCount = v.AffectedAssetsCount,
                    MitigationStatus = v.MitigationStatus,
                    PatchAvailable = v.Patches.Any(p => p.Status == PatchStatus.Available || p.Status == PatchStatus.Deployed),
                    AssignedTo = v.AssignedToName
                })
                .ToListAsync();
            
            return Ok(new PagedResponse<VulnerabilityDto>
            {
                Success = true,
                Message = "تم جلب نقاط الضعف",
                MessageEn = "Vulnerabilities retrieved",
                Data = vulnerabilities,
                Page = page,
                PageSize = pageSize,
                TotalCount = totalCount,
                TotalPages = (int)Math.Ceiling((double)totalCount / pageSize)
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting vulnerabilities");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في جلب نقاط الضعف",
                MessageEn = "Error retrieving vulnerabilities"
            });
        }
    }
    
    /// <summary>
    /// الحصول على تفاصيل نقطة ضعف / Get Vulnerability Details
    /// </summary>
    [HttpGet("vulnerabilities/{id}")]
    public async Task<IActionResult> GetVulnerability(Guid id)
    {
        try
        {
            var vulnerability = await _context.Vulnerabilities
                .Include(v => v.Scans)
                .Include(v => v.Patches)
                    .ThenInclude(p => p.Deployments)
                .Include(v => v.RiskAssessments)
                .FirstOrDefaultAsync(v => v.VulnerabilityId == id && !v.IsDeleted);
            
            if (vulnerability == null)
                return NotFound(new ApiResponse
                {
                    Success = false,
                    Message = "نقطة الضعف غير موجودة",
                    MessageEn = "Vulnerability not found"
                });
            
            var detail = new VulnerabilityDetailDto
            {
                VulnerabilityId = vulnerability.VulnerabilityId,
                CVEId = vulnerability.CVEId,
                Title = vulnerability.Title,
                Description = vulnerability.Description,
                Type = vulnerability.Type,
                Severity = vulnerability.Severity,
                Status = vulnerability.Status,
                CVSSBaseScore = vulnerability.CVSSBaseScore,
                CVSSTemporalScore = vulnerability.CVSSTemporalScore,
                CVSSEnvironmentalScore = vulnerability.CVSSEnvironmentalScore,
                CVSSVector = vulnerability.CVSSVector,
                CVSSVersion = vulnerability.CVSSVersion,
                RiskLevel = vulnerability.RiskLevel,
                Likelihood = vulnerability.Likelihood,
                Impact = vulnerability.Impact,
                IsExploitable = vulnerability.IsExploitable,
                ExploitAvailable = vulnerability.ExploitAvailable,
                ActivelyExploited = vulnerability.ActivelyExploited,
                DiscoveredAt = vulnerability.DiscoveredAt,
                DiscoveredBy = vulnerability.DiscoveredBy,
                DiscoveryMethod = vulnerability.DiscoveryMethod,
                AffectedSystems = vulnerability.AffectedSystems,
                AffectedApplications = vulnerability.AffectedApplications,
                AffectedVersions = vulnerability.AffectedVersions,
                AffectedAssetsCount = vulnerability.AffectedAssetsCount,
                AffectedUsersCount = vulnerability.AffectedUsersCount,
                MitigationSteps = vulnerability.MitigationSteps,
                Workaround = vulnerability.Workaround,
                PatchInformation = vulnerability.PatchInformation,
                PatchAvailableDate = vulnerability.PatchAvailableDate,
                PatchAppliedDate = vulnerability.PatchAppliedDate,
                MitigationStatus = vulnerability.MitigationStatus,
                IsVerified = vulnerability.IsVerified,
                IsFalsePositive = vulnerability.IsFalsePositive,
                AssignedTo = vulnerability.AssignedTo,
                AssignedToName = vulnerability.AssignedToName,
                DueDate = vulnerability.DueDate,
                ResolvedAt = vulnerability.ResolvedAt,
                ResolvedBy = vulnerability.ResolvedBy,
                References = vulnerability.References,
                RelatedCVEs = vulnerability.RelatedCVEs,
                CWEIds = vulnerability.CWEIds,
                OWASPCategory = vulnerability.OWASPCategory,
                Patches = vulnerability.Patches.Select(p => new PatchDto
                {
                    PatchId = p.PatchId,
                    PatchIdentifier = p.PatchIdentifier,
                    PatchName = p.PatchName,
                    Description = p.Description,
                    Vendor = p.Vendor,
                    Product = p.Product,
                    Version = p.Version,
                    ReleaseDate = p.ReleaseDate,
                    Type = p.Type,
                    Priority = p.Priority,
                    Status = p.Status,
                    RequiresTesting = p.RequiresTesting,
                    RequiresReboot = p.RequiresReboot,
                    RequiresDowntime = p.RequiresDowntime,
                    EstimatedDowntimeMinutes = p.EstimatedDowntimeMinutes,
                    DeploymentCount = p.Deployments.Count,
                    SuccessfulDeployments = p.Deployments.Count(d => d.Status == DeploymentStatus.Completed)
                }).ToList(),
                LastRiskAssessment = vulnerability.RiskAssessments
                    .OrderByDescending(r => r.AssessmentDate)
                    .Select(r => new RiskAssessmentDto
                    {
                        AssessmentId = r.AssessmentId,
                        AssessmentDate = r.AssessmentDate,
                        AssessedBy = r.AssessedBy,
                        RiskScore = r.RiskScore,
                        LikelihoodScore = r.LikelihoodScore,
                        ImpactScore = r.ImpactScore,
                        OverallRisk = r.OverallRisk,
                        ResidualRisk = r.ResidualRisk,
                        RiskAccepted = r.RiskAccepted,
                        Treatment = r.Treatment
                    })
                    .FirstOrDefault()
            };
            
            return Ok(new ApiResponse<VulnerabilityDetailDto>
            {
                Success = true,
                Message = "تم جلب تفاصيل نقطة الضعف",
                MessageEn = "Vulnerability details retrieved",
                Data = detail
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting vulnerability details");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في جلب التفاصيل",
                MessageEn = "Error retrieving details"
            });
        }
    }
    
    /// <summary>
    /// إنشاء نقطة ضعف جديدة / Create New Vulnerability
    /// </summary>
    [HttpPost("vulnerabilities")]
    public async Task<IActionResult> CreateVulnerability([FromBody] CreateVulnerabilityRequest request)
    {
        try
        {
            if (!ModelState.IsValid)
                return BadRequest(ModelState);
            
            var vulnerability = new Vulnerability
            {
                CVEId = request.CVEId,
                Title = request.Title,
                Description = request.Description,
                Type = request.Type,
                Severity = request.Severity,
                Status = VulnerabilityStatus.New,
                CVSSBaseScore = request.CVSSBaseScore,
                CVSSVector = request.CVSSVector,
                CVSSVersion = request.CVSSVersion,
                RiskLevel = CalculateRiskLevel(request.CVSSBaseScore ?? 0),
                IsExploitable = request.IsExploitable,
                ExploitAvailable = request.ExploitAvailable,
                DiscoveredAt = DateTime.UtcNow,
                DiscoveredBy = GetUsername(),
                AffectedSystems = request.AffectedSystems,
                AffectedApplications = request.AffectedApplications,
                AffectedVersions = request.AffectedVersions,
                MitigationSteps = request.MitigationSteps,
                Workaround = request.Workaround,
                References = request.References,
                CWEIds = request.CWEIds,
                OWASPCategory = request.OWASPCategory,
                CreatedAt = DateTime.UtcNow,
                CreatedBy = GetUsername()
            };
            
            _context.Vulnerabilities.Add(vulnerability);
            await _context.SaveChangesAsync();
            
            // Send notifications for critical vulnerabilities
            if (vulnerability.Severity == VulnerabilitySeverity.Critical)
            {
                await _notificationService.SendCriticalVulnerabilityAlertAsync(vulnerability);
            }
            
            // Audit log
            await _auditService.LogAsync("VULNERABILITY_CREATED", 
                $"Created vulnerability: {vulnerability.Title}", 
                GetUserId());
            
            return CreatedAtAction(nameof(GetVulnerability), 
                new { id = vulnerability.VulnerabilityId },
                new ApiResponse<Guid>
                {
                    Success = true,
                    Message = "تم إنشاء نقطة الضعف بنجاح",
                    MessageEn = "Vulnerability created successfully",
                    Data = vulnerability.VulnerabilityId
                });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating vulnerability");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في إنشاء نقطة الضعف",
                MessageEn = "Error creating vulnerability"
            });
        }
    }
    
    /// <summary>
    /// تحديث حالة نقطة الضعف / Update Vulnerability Status
    /// </summary>
    [HttpPut("vulnerabilities/{id}/status")]
    public async Task<IActionResult> UpdateVulnerabilityStatus(Guid id, [FromBody] UpdateStatusRequest request)
    {
        try
        {
            var vulnerability = await _context.Vulnerabilities.FindAsync(id);
            
            if (vulnerability == null)
                return NotFound(new ApiResponse
                {
                    Success = false,
                    Message = "نقطة الضعف غير موجودة",
                    MessageEn = "Vulnerability not found"
                });
            
            var previousStatus = vulnerability.Status;
            vulnerability.Status = request.Status;
            vulnerability.UpdatedAt = DateTime.UtcNow;
            vulnerability.UpdatedBy = GetUsername();
            
            if (request.Status == VulnerabilityStatus.Resolved)
            {
                vulnerability.ResolvedAt = DateTime.UtcNow;
                vulnerability.ResolvedBy = GetUsername();
                vulnerability.ResolutionTimeHours = (int)(DateTime.UtcNow - vulnerability.DiscoveredAt).TotalHours;
            }
            
            await _context.SaveChangesAsync();
            
            // Audit log
            await _auditService.LogAsync("VULNERABILITY_STATUS_UPDATED", 
                $"Updated vulnerability {id} status from {previousStatus} to {request.Status}", 
                GetUserId());
            
            return Ok(new ApiResponse
            {
                Success = true,
                Message = "تم تحديث حالة نقطة الضعف",
                MessageEn = "Vulnerability status updated"
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating vulnerability status");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في تحديث الحالة",
                MessageEn = "Error updating status"
            });
        }
    }
    
    #endregion
    
    #region Vulnerability Scanning
    
    /// <summary>
    /// بدء فحص نقاط الضعف / Start Vulnerability Scan
    /// </summary>
    [HttpPost("scans/start")]
    public async Task<IActionResult> StartVulnerabilityScan([FromBody] StartScanRequest request)
    {
        try
        {
            var scan = new VulnerabilityScan
            {
                ScanName = request.ScanName,
                ScanType = request.ScanType,
                ScanDate = DateTime.UtcNow,
                Status = ScanStatus.Pending,
                ScannerName = request.ScannerName,
                ScannerVersion = request.ScannerVersion,
                ScanProfile = request.ScanProfile,
                ScanConfiguration = JsonHelper.Serialize(request.Configuration),
                TargetSystems = JsonHelper.Serialize(request.TargetSystems),
                TargetNetworks = JsonHelper.Serialize(request.TargetNetworks),
                TargetApplications = JsonHelper.Serialize(request.TargetApplications),
                ExcludedTargets = JsonHelper.Serialize(request.ExcludedTargets),
                TotalTargets = request.TargetSystems?.Count ?? 0,
                IsScheduled = request.IsScheduled,
                Schedule = request.Schedule,
                InitiatedBy = GetUsername(),
                IsAutomated = request.IsAutomated,
                CreatedAt = DateTime.UtcNow
            };
            
            _context.VulnerabilityScans.Add(scan);
            await _context.SaveChangesAsync();
            
            // Start scan asynchronously
            _ = Task.Run(async () =>
            {
                try
                {
                    await _scanningService.ExecuteScanAsync(scan.ScanId);
                }
                catch (Exception scanEx)
                {
                    _logger.LogError(scanEx, "Error executing scan {ScanId}", scan.ScanId);
                }
            });
            
            // Audit log
            await _auditService.LogAsync("VULNERABILITY_SCAN_STARTED", 
                $"Started vulnerability scan: {scan.ScanName}", 
                GetUserId());
            
            return Ok(new ApiResponse<Guid>
            {
                Success = true,
                Message = "تم بدء الفحص بنجاح",
                MessageEn = "Scan started successfully",
                Data = scan.ScanId
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error starting vulnerability scan");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في بدء الفحص",
                MessageEn = "Error starting scan"
            });
        }
    }
    
    /// <summary>
    /// الحصول على نتائج الفحص / Get Scan Results
    /// </summary>
    [HttpGet("scans/{scanId}/results")]
    public async Task<IActionResult> GetScanResults(Guid scanId)
    {
        try
        {
            var scan = await _context.VulnerabilityScans
                .Include(s => s.Results)
                    .ThenInclude(r => r.Vulnerability)
                .FirstOrDefaultAsync(s => s.ScanId == scanId);
            
            if (scan == null)
                return NotFound(new ApiResponse
                {
                    Success = false,
                    Message = "الفحص غير موجود",
                    MessageEn = "Scan not found"
                });
            
            var results = scan.Results.Select(r => new ScanResultDto
            {
                ResultId = r.ResultId,
                FindingTitle = r.FindingTitle,
                FindingDescription = r.FindingDescription,
                Severity = r.Severity,
                AssetIdentifier = r.AssetIdentifier,
                IpAddress = r.IpAddress,
                Hostname = r.Hostname,
                Port = r.Port,
                Protocol = r.Protocol,
                Path = r.Path,
                ConfidenceLevel = r.ConfidenceLevel,
                IsConfirmed = r.IsConfirmed,
                IsFalsePositive = r.IsFalsePositive,
                FoundAt = r.FoundAt,
                VulnerabilityId = r.VulnerabilityId,
                CVEId = r.Vulnerability?.CVEId
            }).ToList();
            
            return Ok(new ApiResponse<ScanResultsDto>
            {
                Success = true,
                Message = "تم جلب نتائج الفحص",
                MessageEn = "Scan results retrieved",
                Data = new ScanResultsDto
                {
                    ScanId = scan.ScanId,
                    ScanName = scan.ScanName,
                    Status = scan.Status,
                    StartedAt = scan.StartedAt,
                    CompletedAt = scan.CompletedAt,
                    TotalVulnerabilities = scan.TotalVulnerabilities,
                    CriticalCount = scan.CriticalCount,
                    HighCount = scan.HighCount,
                    MediumCount = scan.MediumCount,
                    LowCount = scan.LowCount,
                    InfoCount = scan.InfoCount,
                    FalsePositiveCount = scan.FalsePositiveCount,
                    Results = results
                }
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting scan results");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في جلب النتائج",
                MessageEn = "Error retrieving results"
            });
        }
    }
    
    #endregion
    
    #region Patch Management
    
    /// <summary>
    /// الحصول على التصحيحات المتاحة / Get Available Patches
    /// </summary>
    [HttpGet("patches")]
    public async Task<IActionResult> GetPatches(
        [FromQuery] PatchStatus? status = null,
        [FromQuery] PatchPriority? priority = null)
    {
        try
        {
            var query = _context.Patches
                .Include(p => p.Deployments)
                .AsQueryable();
            
            if (status.HasValue)
                query = query.Where(p => p.Status == status.Value);
            
            if (priority.HasValue)
                query = query.Where(p => p.Priority == priority.Value);
            
            var patches = await query
                .OrderByDescending(p => p.Priority)
                .ThenByDescending(p => p.ReleaseDate)
                .Select(p => new PatchDto
                {
                    PatchId = p.PatchId,
                    PatchIdentifier = p.PatchIdentifier,
                    PatchName = p.PatchName,
                    Description = p.Description,
                    Vendor = p.Vendor,
                    Product = p.Product,
                    Version = p.Version,
                    ReleaseDate = p.ReleaseDate,
                    Type = p.Type,
                    Priority = p.Priority,
                    Status = p.Status,
                    VulnerabilitiesFixed = p.VulnerabilitiesFixed,
                    CVEIds = p.CVEIds,
                    RequiresTesting = p.RequiresTesting,
                    RequiresReboot = p.RequiresReboot,
                    RequiresDowntime = p.RequiresDowntime,
                    EstimatedDowntimeMinutes = p.EstimatedDowntimeMinutes,
                    SystemsPatched = p.SystemsPatched,
                    SystemsPending = p.SystemsPending,
                    SystemsFailed = p.SystemsFailed,
                    IsApproved = p.IsApproved,
                    ScheduledDeployment = p.ScheduledDeployment
                })
                .ToListAsync();
            
            return Ok(new ApiResponse<List<PatchDto>>
            {
                Success = true,
                Message = "تم جلب التصحيحات",
                MessageEn = "Patches retrieved",
                Data = patches
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting patches");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في جلب التصحيحات",
                MessageEn = "Error retrieving patches"
            });
        }
    }
    
    /// <summary>
    /// نشر التصحيح / Deploy Patch
    /// </summary>
    [HttpPost("patches/{patchId}/deploy")]
    public async Task<IActionResult> DeployPatch(Guid patchId, [FromBody] DeployPatchRequest request)
    {
        try
        {
            var patch = await _context.Patches.FindAsync(patchId);
            
            if (patch == null)
                return NotFound(new ApiResponse
                {
                    Success = false,
                    Message = "التصحيح غير موجود",
                    MessageEn = "Patch not found"
                });
            
            if (!patch.IsApproved && patch.RequiresApproval)
                return BadRequest(new ApiResponse
                {
                    Success = false,
                    Message = "التصحيح يحتاج إلى موافقة أولاً",
                    MessageEn = "Patch requires approval first"
                });
            
            // Create deployment records
            var deployments = new List<PatchDeployment>();
            foreach (var targetSystem in request.TargetSystems)
            {
                var deployment = new PatchDeployment
                {
                    PatchId = patchId,
                    DeploymentDate = request.ScheduledDate ?? DateTime.UtcNow,
                    TargetSystem = targetSystem,
                    Status = DeploymentStatus.Pending,
                    DeployedBy = GetUsername(),
                    IsAutomated = request.IsAutomated
                };
                
                deployments.Add(deployment);
                _context.PatchDeployments.Add(deployment);
            }
            
            // Update patch status
            patch.Status = PatchStatus.Deploying;
            patch.SystemsPending = deployments.Count;
            
            await _context.SaveChangesAsync();
            
            // Start deployment asynchronously
            _ = Task.Run(async () =>
            {
                foreach (var deployment in deployments)
                {
                    try
                    {
                        await _patchService.DeployPatchAsync(deployment.DeploymentId);
                    }
                    catch (Exception deployEx)
                    {
                        _logger.LogError(deployEx, "Error deploying patch {DeploymentId}", deployment.DeploymentId);
                    }
                }
            });
            
            // Audit log
            await _auditService.LogAsync("PATCH_DEPLOYMENT_STARTED", 
                $"Started deployment of patch: {patch.PatchName}", 
                GetUserId());
            
            return Ok(new ApiResponse<int>
            {
                Success = true,
                Message = "تم بدء نشر التصحيح",
                MessageEn = "Patch deployment started",
                Data = deployments.Count
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deploying patch");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في نشر التصحيح",
                MessageEn = "Error deploying patch"
            });
        }
    }
    
    #endregion
    
    #region Risk Assessment
    
    /// <summary>
    /// إجراء تقييم المخاطر / Perform Risk Assessment
    /// </summary>
    [HttpPost("vulnerabilities/{vulnerabilityId}/assess-risk")]
    public async Task<IActionResult> AssessRisk(Guid vulnerabilityId, [FromBody] RiskAssessmentRequest request)
    {
        try
        {
            var vulnerability = await _context.Vulnerabilities.FindAsync(vulnerabilityId);
            
            if (vulnerability == null)
                return NotFound(new ApiResponse
                {
                    Success = false,
                    Message = "نقطة الضعف غير موجودة",
                    MessageEn = "Vulnerability not found"
                });
            
            // Calculate risk scores
            var riskScore = (request.LikelihoodScore * request.ImpactScore) / 25.0 * 100;
            var overallRisk = CalculateOverallRisk(riskScore);
            
            var assessment = new RiskAssessment
            {
                VulnerabilityId = vulnerabilityId,
                AssessmentDate = DateTime.UtcNow,
                AssessedBy = GetUsername(),
                RiskScore = riskScore,
                LikelihoodScore = request.LikelihoodScore,
                ImpactScore = request.ImpactScore,
                OverallRisk = overallRisk,
                ThreatSources = JsonHelper.Serialize(request.ThreatSources),
                ThreatEvents = JsonHelper.Serialize(request.ThreatEvents),
                ImpactTypes = JsonHelper.Serialize(request.ImpactTypes),
                FinancialImpact = request.FinancialImpact,
                OperationalImpact = request.OperationalImpact,
                ReputationalImpact = request.ReputationalImpact,
                ComplianceImpact = request.ComplianceImpact,
                AffectedUsers = request.AffectedUsers,
                DowntimeHours = request.DowntimeHours,
                ExistingControls = JsonHelper.Serialize(request.ExistingControls),
                RecommendedControls = JsonHelper.Serialize(request.RecommendedControls),
                ResidualRisk = request.ResidualRisk,
                Treatment = request.Treatment,
                TreatmentPlan = request.TreatmentPlan,
                TreatmentDeadline = request.TreatmentDeadline,
                TreatmentOwner = request.TreatmentOwner,
                CreatedAt = DateTime.UtcNow
            };
            
            _context.RiskAssessments.Add(assessment);
            
            // Update vulnerability risk level
            vulnerability.RiskLevel = overallRisk;
            vulnerability.Likelihood = request.LikelihoodScore;
            vulnerability.Impact = request.ImpactScore;
            
            await _context.SaveChangesAsync();
            
            // Send notification for high risk
            if (overallRisk >= RiskLevel.High)
            {
                await _notificationService.SendHighRiskAlertAsync(vulnerability, assessment);
            }
            
            // Audit log
            await _auditService.LogAsync("RISK_ASSESSMENT_PERFORMED", 
                $"Risk assessment for vulnerability: {vulnerability.Title}", 
                GetUserId());
            
            return Ok(new ApiResponse<RiskAssessmentResultDto>
            {
                Success = true,
                Message = "تم تقييم المخاطر بنجاح",
                MessageEn = "Risk assessed successfully",
                Data = new RiskAssessmentResultDto
                {
                    AssessmentId = assessment.AssessmentId,
                    RiskScore = riskScore,
                    OverallRisk = overallRisk,
                    ResidualRisk = request.ResidualRisk ?? 0,
                    Treatment = request.Treatment,
                    RequiresImmediateAction = overallRisk >= RiskLevel.High
                }
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error performing risk assessment");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في تقييم المخاطر",
                MessageEn = "Error assessing risk"
            });
        }
    }
    
    #endregion
    
    #region Dashboard and Statistics
    
    /// <summary>
    /// الحصول على إحصائيات نقاط الضعف / Get Vulnerability Statistics
    /// </summary>
    [HttpGet("statistics")]
    public async Task<IActionResult> GetVulnerabilityStatistics()
    {
        try
        {
            var today = DateTime.UtcNow.Date;
            var last30Days = today.AddDays(-30);
            
            var stats = new VulnerabilityStatistics
            {
                // Overall statistics
                TotalVulnerabilities = await _context.Vulnerabilities.CountAsync(v => !v.IsDeleted),
                ActiveVulnerabilities = await _context.Vulnerabilities.CountAsync(v => 
                    v.Status != VulnerabilityStatus.Resolved && 
                    v.Status != VulnerabilityStatus.FalsePositive && 
                    !v.IsDeleted),
                ResolvedVulnerabilities = await _context.Vulnerabilities.CountAsync(v => 
                    v.Status == VulnerabilityStatus.Resolved && !v.IsDeleted),
                
                // By severity
                CriticalVulnerabilities = await _context.Vulnerabilities.CountAsync(v => 
                    v.Severity == VulnerabilitySeverity.Critical && 
                    v.Status != VulnerabilityStatus.Resolved && 
                    !v.IsDeleted),
                HighVulnerabilities = await _context.Vulnerabilities.CountAsync(v => 
                    v.Severity == VulnerabilitySeverity.High && 
                    v.Status != VulnerabilityStatus.Resolved && 
                    !v.IsDeleted),
                MediumVulnerabilities = await _context.Vulnerabilities.CountAsync(v => 
                    v.Severity == VulnerabilitySeverity.Medium && 
                    v.Status != VulnerabilityStatus.Resolved && 
                    !v.IsDeleted),
                LowVulnerabilities = await _context.Vulnerabilities.CountAsync(v => 
                    v.Severity == VulnerabilitySeverity.Low && 
                    v.Status != VulnerabilityStatus.Resolved && 
                    !v.IsDeleted),
                
                // Exploitability
                ExploitableVulnerabilities = await _context.Vulnerabilities.CountAsync(v => 
                    v.IsExploitable && v.Status != VulnerabilityStatus.Resolved && !v.IsDeleted),
                ActivelyExploited = await _context.Vulnerabilities.CountAsync(v => 
                    v.ActivelyExploited && v.Status != VulnerabilityStatus.Resolved && !v.IsDeleted),
                
                // Recent activity
                DiscoveredLast30Days = await _context.Vulnerabilities.CountAsync(v => 
                    v.DiscoveredAt >= last30Days && !v.IsDeleted),
                ResolvedLast30Days = await _context.Vulnerabilities.CountAsync(v => 
                    v.ResolvedAt >= last30Days && !v.IsDeleted),
                
                // Patches
                TotalPatches = await _context.Patches.CountAsync(),
                AvailablePatches = await _context.Patches.CountAsync(p => p.Status == PatchStatus.Available),
                DeployedPatches = await _context.Patches.CountAsync(p => p.Status == PatchStatus.Deployed),
                PendingPatches = await _context.Patches.CountAsync(p => 
                    p.Status == PatchStatus.Testing || p.Status == PatchStatus.Approved),
                
                // Mean time to resolution
                AverageResolutionTimeHours = await _context.Vulnerabilities
                    .Where(v => v.Status == VulnerabilityStatus.Resolved && v.ResolutionTimeHours.HasValue)
                    .AverageAsync(v => (double?)v.ResolutionTimeHours) ?? 0,
                
                // Scan statistics
                TotalScans = await _context.VulnerabilityScans.CountAsync(),
                CompletedScans = await _context.VulnerabilityScans.CountAsync(s => s.Status == ScanStatus.Completed),
                ScheduledScans = await _context.VulnerabilityScans.CountAsync(s => s.IsScheduled && s.Status == ScanStatus.Pending),
                
                // Top vulnerable systems
                TopVulnerableSystems = await _context.Vulnerabilities
                    .Where(v => v.Status != VulnerabilityStatus.Resolved && !v.IsDeleted && v.AffectedSystems != null)
                    .GroupBy(v => v.AffectedSystems)
                    .Select(g => new SystemVulnerabilityCount
                    {
                        SystemName = g.Key ?? "Unknown",
                        VulnerabilityCount = g.Count()
                    })
                    .OrderByDescending(s => s.VulnerabilityCount)
                    .Take(5)
                    .ToListAsync()
            };
            
            return Ok(new ApiResponse<VulnerabilityStatistics>
            {
                Success = true,
                Message = "تم جلب الإحصائيات",
                MessageEn = "Statistics retrieved",
                Data = stats
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting vulnerability statistics");
            return StatusCode(500, new ApiResponse
            {
                Success = false,
                Message = "حدث خطأ في جلب الإحصائيات",
                MessageEn = "Error retrieving statistics"
            });
        }
    }
    
    #endregion
    
    #region Helper Methods
    
    private Guid GetUserId()
    {
        var userIdClaim = User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
        return Guid.Parse(userIdClaim ?? Guid.Empty.ToString());
    }
    
    private string GetUsername()
    {
        return User.FindFirst(System.Security.Claims.ClaimTypes.Name)?.Value ?? "System";
    }
    
    private RiskLevel CalculateRiskLevel(double cvssScore)
    {
        return cvssScore switch
        {
            >= 9.0 => RiskLevel.Critical,
            >= 7.0 => RiskLevel.VeryHigh,
            >= 5.0 => RiskLevel.High,
            >= 3.0 => RiskLevel.Medium,
            >= 1.0 => RiskLevel.Low,
            _ => RiskLevel.VeryLow
        };
    }
    
    private RiskLevel CalculateOverallRisk(double riskScore)
    {
        return riskScore switch
        {
            >= 80 => RiskLevel.Critical,
            >= 60 => RiskLevel.VeryHigh,
            >= 40 => RiskLevel.High,
            >= 20 => RiskLevel.Medium,
            >= 10 => RiskLevel.Low,
            _ => RiskLevel.VeryLow
        };
    }
    
    #endregion
    
    #region DTOs
    
    public class ApiResponse
    {
        public bool Success { get; set; }
        public string Message { get; set; } = string.Empty;
        public string? MessageEn { get; set; }
    }
    
    public class ApiResponse<T> : ApiResponse
    {
        public T? Data { get; set; }
    }
    
    public class PagedResponse<T> : ApiResponse<List<T>>
    {
        public int Page { get; set; }
        public int PageSize { get; set; }
        public int TotalCount { get; set; }
        public int TotalPages { get; set; }
    }
    
    public class VulnerabilityDto
    {
        public Guid VulnerabilityId { get; set; }
        public string? CVEId { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public VulnerabilityType Type { get; set; }
        public VulnerabilitySeverity Severity { get; set; }
        public VulnerabilityStatus Status { get; set; }
        public double? CVSSBaseScore { get; set; }
        public string? CVSSVector { get; set; }
        public RiskLevel RiskLevel { get; set; }
        public bool IsExploitable { get; set; }
        public bool ExploitAvailable { get; set; }
        public bool ActivelyExploited { get; set; }
        public DateTime DiscoveredAt { get; set; }
        public int AffectedAssetsCount { get; set; }
        public MitigationStatus MitigationStatus { get; set; }
        public bool PatchAvailable { get; set; }
        public string? AssignedTo { get; set; }
    }
    
    public class VulnerabilityDetailDto : VulnerabilityDto
    {
        public double? CVSSTemporalScore { get; set; }
        public double? CVSSEnvironmentalScore { get; set; }
        public CVSSVersion? CVSSVersion { get; set; }
        public double? Likelihood { get; set; }
        public double? Impact { get; set; }
        public string? DiscoveredBy { get; set; }
        public string? DiscoveryMethod { get; set; }
        public string? AffectedSystems { get; set; }
        public string? AffectedApplications { get; set; }
        public string? AffectedVersions { get; set; }
        public int AffectedUsersCount { get; set; }
        public string? MitigationSteps { get; set; }
        public string? Workaround { get; set; }
        public string? PatchInformation { get; set; }
        public DateTime? PatchAvailableDate { get; set; }
        public DateTime? PatchAppliedDate { get; set; }
        public bool IsVerified { get; set; }
        public bool IsFalsePositive { get; set; }
        public Guid? AssignedTo { get; set; }
        public string? AssignedToName { get; set; }
        public DateTime? DueDate { get; set; }
        public DateTime? ResolvedAt { get; set; }
        public string? ResolvedBy { get; set; }
        public string? References { get; set; }
        public string? RelatedCVEs { get; set; }
        public string? CWEIds { get; set; }
        public string? OWASPCategory { get; set; }
        public List<PatchDto> Patches { get; set; } = new();
        public RiskAssessmentDto? LastRiskAssessment { get; set; }
    }
    
    public class CreateVulnerabilityRequest
    {
        public string? CVEId { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public VulnerabilityType Type { get; set; }
        public VulnerabilitySeverity Severity { get; set; }
        public double? CVSSBaseScore { get; set; }
        public string? CVSSVector { get; set; }
        public CVSSVersion? CVSSVersion { get; set; }
        public bool IsExploitable { get; set; }
        public bool ExploitAvailable { get; set; }
        public string? AffectedSystems { get; set; }
        public string? AffectedApplications { get; set; }
        public string? AffectedVersions { get; set; }
        public string? MitigationSteps { get; set; }
        public string? Workaround { get; set; }
        public string? References { get; set; }
        public string? CWEIds { get; set; }
        public string? OWASPCategory { get; set; }
    }
    
    public class UpdateStatusRequest
    {
        public VulnerabilityStatus Status { get; set; }
    }
    
    public class StartScanRequest
    {
        public string ScanName { get; set; } = string.Empty;
        public ScanType ScanType { get; set; }
        public string ScannerName { get; set; } = string.Empty;
        public string? ScannerVersion { get; set; }
        public string? ScanProfile { get; set; }
        public Dictionary<string, object>? Configuration { get; set; }
        public List<string>? TargetSystems { get; set; }
        public List<string>? TargetNetworks { get; set; }
        public List<string>? TargetApplications { get; set; }
        public List<string>? ExcludedTargets { get; set; }
        public bool IsScheduled { get; set; }
        public string? Schedule { get; set; }
        public bool IsAutomated { get; set; }
    }
    
    public class ScanResultDto
    {
        public Guid ResultId { get; set; }
        public string FindingTitle { get; set; } = string.Empty;
        public string FindingDescription { get; set; } = string.Empty;
        public VulnerabilitySeverity Severity { get; set; }
        public string? AssetIdentifier { get; set; }
        public string? IpAddress { get; set; }
        public string? Hostname { get; set; }
        public string? Port { get; set; }
        public string? Protocol { get; set; }
        public string? Path { get; set; }
        public int ConfidenceLevel { get; set; }
        public bool IsConfirmed { get; set; }
        public bool IsFalsePositive { get; set; }
        public DateTime FoundAt { get; set; }
        public Guid? VulnerabilityId { get; set; }
        public string? CVEId { get; set; }
    }
    
    public class ScanResultsDto
    {
        public Guid ScanId { get; set; }
        public string ScanName { get; set; } = string.Empty;
        public ScanStatus Status { get; set; }
        public DateTime? StartedAt { get; set; }
        public DateTime? CompletedAt { get; set; }
        public int TotalVulnerabilities { get; set; }
        public int CriticalCount { get; set; }
        public int HighCount { get; set; }
        public int MediumCount { get; set; }
        public int LowCount { get; set; }
        public int InfoCount { get; set; }
        public int FalsePositiveCount { get; set; }
        public List<ScanResultDto> Results { get; set; } = new();
    }
    
    public class PatchDto
    {
        public Guid PatchId { get; set; }
        public string PatchIdentifier { get; set; } = string.Empty;
        public string PatchName { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string Vendor { get; set; } = string.Empty;
        public string? Product { get; set; }
        public string? Version { get; set; }
        public DateTime ReleaseDate { get; set; }
        public PatchType Type { get; set; }
        public PatchPriority Priority { get; set; }
        public PatchStatus Status { get; set; }
        public int VulnerabilitiesFixed { get; set; }
        public string? CVEIds { get; set; }
        public bool RequiresTesting { get; set; }
        public bool RequiresReboot { get; set; }
        public bool RequiresDowntime { get; set; }
        public int EstimatedDowntimeMinutes { get; set; }
        public int SystemsPatched { get; set; }
        public int SystemsPending { get; set; }
        public int SystemsFailed { get; set; }
        public bool IsApproved { get; set; }
        public DateTime? ScheduledDeployment { get; set; }
        public int? DeploymentCount { get; set; }
        public int? SuccessfulDeployments { get; set; }
    }
    
    public class DeployPatchRequest
    {
        public List<string> TargetSystems { get; set; } = new();
        public DateTime? ScheduledDate { get; set; }
        public bool IsAutomated { get; set; }
    }
    
    public class RiskAssessmentDto
    {
        public Guid AssessmentId { get; set; }
        public DateTime AssessmentDate { get; set; }
        public string AssessedBy { get; set; } = string.Empty;
        public double RiskScore { get; set; }
        public double LikelihoodScore { get; set; }
        public double ImpactScore { get; set; }
        public RiskLevel OverallRisk { get; set; }
        public double? ResidualRisk { get; set; }
        public bool RiskAccepted { get; set; }
        public RiskTreatment Treatment { get; set; }
    }
    
    public class RiskAssessmentRequest
    {
        public double LikelihoodScore { get; set; }
        public double ImpactScore { get; set; }
        public List<string>? ThreatSources { get; set; }
        public List<string>? ThreatEvents { get; set; }
        public List<string>? ImpactTypes { get; set; }
        public decimal? FinancialImpact { get; set; }
        public string? OperationalImpact { get; set; }
        public string? ReputationalImpact { get; set; }
        public string? ComplianceImpact { get; set; }
        public int? AffectedUsers { get; set; }
        public int? DowntimeHours { get; set; }
        public List<string>? ExistingControls { get; set; }
        public List<string>? RecommendedControls { get; set; }
        public double? ResidualRisk { get; set; }
        public RiskTreatment Treatment { get; set; }
        public string? TreatmentPlan { get; set; }
        public DateTime? TreatmentDeadline { get; set; }
        public string? TreatmentOwner { get; set; }
    }
    
    public class RiskAssessmentResultDto
    {
        public Guid AssessmentId { get; set; }
        public double RiskScore { get; set; }
        public RiskLevel OverallRisk { get; set; }
        public double ResidualRisk { get; set; }
        public RiskTreatment Treatment { get; set; }
        public bool RequiresImmediateAction { get; set; }
    }
    
    public class VulnerabilityStatistics
    {
        public int TotalVulnerabilities { get; set; }
        public int ActiveVulnerabilities { get; set; }
        public int ResolvedVulnerabilities { get; set; }
        public int CriticalVulnerabilities { get; set; }
        public int HighVulnerabilities { get; set; }
        public int MediumVulnerabilities { get; set; }
        public int LowVulnerabilities { get; set; }
        public int ExploitableVulnerabilities { get; set; }
        public int ActivelyExploited { get; set; }
        public int DiscoveredLast30Days { get; set; }
        public int ResolvedLast30Days { get; set; }
        public int TotalPatches { get; set; }
        public int AvailablePatches { get; set; }
        public int DeployedPatches { get; set; }
        public int PendingPatches { get; set; }
        public double AverageResolutionTimeHours { get; set; }
        public int TotalScans { get; set; }
        public int CompletedScans { get; set; }
        public int ScheduledScans { get; set; }
        public List<SystemVulnerabilityCount> TopVulnerableSystems { get; set; } = new();
    }
    
    public class SystemVulnerabilityCount
    {
        public string SystemName { get; set; } = string.Empty;
        public int VulnerabilityCount { get; set; }
    }
    
    #endregion
}}
</artifact>
</artifacts>*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using SabaFone.Backend.Services;
using SabaFone.Backend.Data.Vulnerabilities.Models;

namespace SabaFone.Backend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize]
    public class VulnerabilityController : ControllerBase
    {
        private readonly IVulnerabilityService _vulnerabilityService;
        private readonly IScanningService _scanningService;
        private readonly IPatchManagementService _patchService;
        private readonly IAuditService _auditService;
        private readonly INotificationService _notificationService;
        private readonly ILogger<VulnerabilityController> _logger;

        public VulnerabilityController(
            IVulnerabilityService vulnerabilityService,
            IScanningService scanningService,
            IPatchManagementService patchService,
            IAuditService auditService,
            INotificationService notificationService,
            ILogger<VulnerabilityController> logger)
        {
            _vulnerabilityService = vulnerabilityService;
            _scanningService = scanningService;
            _patchService = patchService;
            _auditService = auditService;
            _notificationService = notificationService;
            _logger = logger;
        }

        /// <summary>
        /// Gets vulnerability dashboard
        /// </summary>
        [HttpGet("dashboard")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> GetDashboard()
        {
            try
            {
                var statistics = await _vulnerabilityService.GetVulnerabilityStatisticsAsync();
                var activeVulns = await _vulnerabilityService.GetActiveVulnerabilitiesAsync();
                var trends = await _vulnerabilityService.GetVulnerabilityTrendsAsync(6);
                var latestCves = await _vulnerabilityService.GetLatestCveEntriesAsync(10);

                return Ok(new
                {
                    statistics,
                    activeVulnerabilities = activeVulns.Take(10),
                    trends,
                    latestCves,
                    timestamp = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting vulnerability dashboard");
                return StatusCode(500, new { message = "An error occurred while getting dashboard" });
            }
        }

        /// <summary>
        /// Gets all vulnerabilities
        /// </summary>
        [HttpGet]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst,Auditor")]
        public async Task<IActionResult> GetVulnerabilities(
            [FromQuery] string severity = null,
            [FromQuery] string status = null,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 50)
        {
            try
            {
                var vulnerabilities = await _vulnerabilityService.GetActiveVulnerabilitiesAsync();
                
                // Apply filters
                if (!string.IsNullOrEmpty(severity))
                {
                    vulnerabilities = vulnerabilities.Where(v => v.Severity == severity).ToList();
                }
                
                if (!string.IsNullOrEmpty(status))
                {
                    vulnerabilities = vulnerabilities.Where(v => v.Status == status).ToList();
                }

                // Pagination
                var totalCount = vulnerabilities.Count;
                var items = vulnerabilities
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .Select(v => new VulnerabilityDto
                    {
                        VulnerabilityId = v.VulnerabilityId,
                        Title = v.Title,
                        Description = v.Description,
                        Severity = v.Severity,
                        Status = v.Status,
                        CVSSScore = v.CVSSScore,
                        RiskScore = v.RiskScore,
                        DiscoveredAt = v.DiscoveredAt,
                        ResolvedAt = v.ResolvedAt,
                        AffectedAssets = v.AffectedAssets,
                        IsExploitable = v.IsExploitable
                    });

                return Ok(new
                {
                    items,
                    totalCount,
                    page,
                    pageSize,
                    totalPages = (int)Math.Ceiling(totalCount / (double)pageSize)
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting vulnerabilities");
                return StatusCode(500, new { message = "An error occurred while getting vulnerabilities" });
            }
        }

        /// <summary>
        /// Gets vulnerability by ID
        /// </summary>
        [HttpGet("{vulnerabilityId}")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> GetVulnerability(Guid vulnerabilityId)
        {
            try
            {
                var vulnerability = await _vulnerabilityService.GetVulnerabilityAsync(vulnerabilityId);
                
                if (vulnerability == null)
                {
                    return NotFound(new { message = "Vulnerability not found" });
                }

                var riskScore = await _vulnerabilityService.CalculateRiskScoreAsync(vulnerabilityId);
                var recommendations = await _vulnerabilityService.GetRemediationRecommendationsAsync(vulnerabilityId);

                return Ok(new
                {
                    vulnerability,
                    riskScore,
                    recommendations
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error getting vulnerability {vulnerabilityId}");
                return StatusCode(500, new { message = "An error occurred while getting vulnerability" });
            }
        }

        /// <summary>
        /// Creates new vulnerability
        /// </summary>
        [HttpPost]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> CreateVulnerability([FromBody] CreateVulnerabilityRequest request)
        {
            try
            {
                var vulnerability = new Vulnerability
                {
                    Title = request.Title,
                    Description = request.Description,
                    Severity = request.Severity,
                    Type = request.Type,
                    CVSSScore = request.CVSSScore,
                    AffectedAssets = request.AffectedAssets,
                    IsExploitable = request.IsExploitable,
                    DiscoveredBy = User.Identity.Name
                };

                var created = await _vulnerabilityService.CreateVulnerabilityAsync(vulnerability);

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "VULNERABILITY_CREATED",
                    $"Vulnerability created: {created.Title}",
                    userId);

                if (vulnerability.Severity == "Critical" || vulnerability.Severity == "High")
                {
                    await _notificationService.SendSecurityAlertAsync(
                        vulnerability.Severity,
                        $"New {vulnerability.Severity} vulnerability discovered: {vulnerability.Title}");
                }

                return CreatedAtAction(nameof(GetVulnerability), 
                    new { vulnerabilityId = created.VulnerabilityId }, 
                    new { vulnerabilityId = created.VulnerabilityId, message = "Vulnerability created successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating vulnerability");
                return StatusCode(500, new { message = "An error occurred while creating vulnerability" });
            }
        }

        /// <summary>
        /// Updates vulnerability status
        /// </summary>
        [HttpPut("{vulnerabilityId}/status")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> UpdateVulnerabilityStatus(
            Guid vulnerabilityId,
            [FromBody] UpdateStatusRequest request)
        {
            try
            {
                var result = await _vulnerabilityService.UpdateVulnerabilityStatusAsync(
                    vulnerabilityId,
                    request.Status);

                if (!result)
                {
                    return NotFound(new { message = "Vulnerability not found" });
                }

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "VULNERABILITY_STATUS_UPDATED",
                    $"Vulnerability {vulnerabilityId} status updated to {request.Status}",
                    userId);

                return Ok(new { message = "Status updated successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error updating vulnerability status {vulnerabilityId}");
                return StatusCode(500, new { message = "An error occurred while updating status" });
            }
        }

        /// <summary>
        /// Creates remediation plan
        /// </summary>
        [HttpPost("{vulnerabilityId}/remediation")]
        [Authorize(Roles = "Admin,SecurityOfficer")]
        public async Task<IActionResult> CreateRemediationPlan(
            Guid vulnerabilityId,
            [FromBody] RemediationPlanRequest request)
        {
            try
            {
                var plan = new Dictionary<string, object>
                {
                    ["Title"] = request.Title,
                    ["Description"] = request.Description,
                    ["Steps"] = request.Steps,
                    ["EstimatedHours"] = request.EstimatedHours,
                    ["Priority"] = request.Priority,
                    ["AssignedTo"] = request.AssignedTo
                };

                var result = await _vulnerabilityService.CreateRemediationPlanAsync(vulnerabilityId, plan);

                if (!result)
                {
                    return NotFound(new { message = "Vulnerability not found" });
                }

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "REMEDIATION_PLAN_CREATED",
                    $"Remediation plan created for vulnerability {vulnerabilityId}",
                    userId);

                return Ok(new { message = "Remediation plan created successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error creating remediation plan for {vulnerabilityId}");
                return StatusCode(500, new { message = "An error occurred while creating plan" });
            }
        }

        /// <summary>
        /// Updates remediation progress
        /// </summary>
        [HttpPut("{vulnerabilityId}/remediation/progress")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> UpdateRemediationProgress(
            Guid vulnerabilityId,
            [FromBody] UpdateProgressRequest request)
        {
            try
            {
                var result = await _vulnerabilityService.TrackRemediationProgressAsync(
                    vulnerabilityId,
                    request.ProgressPercentage);

                if (!result)
                {
                    return NotFound(new { message = "Vulnerability not found" });
                }

                if (request.ProgressPercentage == 100)
                {
                    await _notificationService.SendRoleBasedNotificationAsync(
                        "SecurityOfficer",
                        "Remediation Completed",
                        $"Vulnerability {vulnerabilityId} has been fully remediated");
                }

                return Ok(new { message = "Progress updated successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error updating remediation progress for {vulnerabilityId}");
                return StatusCode(500, new { message = "An error occurred while updating progress" });
            }
        }

        /// <summary>
        /// Starts vulnerability scan
        /// </summary>
        [HttpPost("scan")]
        [Authorize(Roles = "Admin,SecurityOfficer")]
        public async Task<IActionResult> StartScan([FromBody] ScanRequest request)
        {
            try
            {
                var scanId = await _scanningService.StartScanAsync(
                    request.ScanType,
                    request.Targets,
                    request.Options);

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "VULNERABILITY_SCAN_STARTED",
                    $"Vulnerability scan started. Type: {request.ScanType}",
                    userId);

                return Ok(new { scanId, message = "Scan started successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error starting vulnerability scan");
                return StatusCode(500, new { message = "An error occurred while starting scan" });
            }
        }

        /// <summary>
        /// Gets scan status
        /// </summary>
        [HttpGet("scan/{scanId}/status")]
        public async Task<IActionResult> GetScanStatus(Guid scanId)
        {
            try
            {
                var status = await _scanningService.GetScanStatusAsync(scanId);
                
                if (status == null)
                {
                    return NotFound(new { message = "Scan not found" });
                }

                return Ok(status);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error getting scan status {scanId}");
                return StatusCode(500, new { message = "An error occurred while getting scan status" });
            }
        }

        /// <summary>
        /// Gets scan results
        /// </summary>
        [HttpGet("scan/{scanId}/results")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> GetScanResults(Guid scanId)
        {
            try
            {
                var results = await _scanningService.GetScanResultsAsync(scanId);
                
                if (results == null)
                {
                    return NotFound(new { message = "Scan results not found" });
                }

                return Ok(results);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error getting scan results {scanId}");
                return StatusCode(500, new { message = "An error occurred while getting results" });
            }
        }

        /// <summary>
        /// Schedules vulnerability scan
        /// </summary>
        [HttpPost("scan/schedule")]
        [Authorize(Roles = "Admin,SecurityOfficer")]
        public async Task<IActionResult> ScheduleScan([FromBody] ScheduleScanRequest request)
        {
            try
            {
                var scheduleId = await _scanningService.ScheduleScanAsync(
                    request.ScanType,
                    request.Targets,
                    request.Schedule);

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "SCAN_SCHEDULED",
                    $"Vulnerability scan scheduled: {request.Schedule}",
                    userId);

                return Ok(new { scheduleId, message = "Scan scheduled successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scheduling scan");
                return StatusCode(500, new { message = "An error occurred while scheduling scan" });
            }
        }

        /// <summary>
        /// Gets available patches
        /// </summary>
        [HttpGet("patches")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> GetAvailablePatches()
        {
            try
            {
                var patches = await _patchService.GetAvailablePatchesAsync();
                return Ok(patches);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting available patches");
                return StatusCode(500, new { message = "An error occurred while getting patches" });
            }
        }

        /// <summary>
        /// Approves patch
        /// </summary>
        [HttpPost("patches/{patchId}/approve")]
        [Authorize(Roles = "Admin,SecurityOfficer")]
        public async Task<IActionResult> ApprovePatch(Guid patchId)
        {
            try
            {
                var result = await _patchService.ApprovePatchAsync(patchId);
                
                if (!result)
                {
                    return NotFound(new { message = "Patch not found" });
                }

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "PATCH_APPROVED",
                    $"Patch {patchId} approved for deployment",
                    userId);

                return Ok(new { message = "Patch approved successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error approving patch {patchId}");
                return StatusCode(500, new { message = "An error occurred while approving patch" });
            }
        }

        /// <summary>
        /// Deploys patch
        /// </summary>
        [HttpPost("patches/{patchId}/deploy")]
        [Authorize(Roles = "Admin,SecurityOfficer")]
        public async Task<IActionResult> DeployPatch(Guid patchId, [FromBody] DeployPatchRequest request)
        {
            try
            {
                var deploymentId = await _patchService.SchedulePatchDeploymentAsync(
                    patchId,
                    request.ScheduledTime ?? DateTime.UtcNow,
                    request.Targets);

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "PATCH_DEPLOYMENT_SCHEDULED",
                    $"Patch {patchId} scheduled for deployment",
                    userId);

                return Ok(new { deploymentId, message = "Patch deployment scheduled" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error deploying patch {patchId}");
                return StatusCode(500, new { message = "An error occurred while deploying patch" });
            }
        }

        /// <summary>
        /// Performs risk analysis
        /// </summary>
        [HttpPost("risk-analysis")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst")]
        public async Task<IActionResult> PerformRiskAnalysis([FromBody] RiskAnalysisRequest request)
        {
            try
            {
                var analysis = await _vulnerabilityService.PerformRiskAnalysisAsync(request.VulnerabilityIds);
                
                return Ok(analysis);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error performing risk analysis");
                return StatusCode(500, new { message = "An error occurred while performing analysis" });
            }
        }

        /// <summary>
        /// Imports vulnerabilities from scanner
        /// </summary>
        [HttpPost("import")]
        [Authorize(Roles = "Admin,SecurityOfficer")]
        public async Task<IActionResult> ImportVulnerabilities(
            IFormFile file,
            [FromQuery] string scannerType)
        {
            try
            {
                if (file == null || file.Length == 0)
                {
                    return BadRequest(new { message = "No file provided" });
                }

                using (var stream = file.OpenReadStream())
                {
                    var data = new byte[file.Length];
                    await stream.ReadAsync(data, 0, data.Length);
                    
                    var result = await _vulnerabilityService.ImportVulnerabilitiesFromScannerAsync(
                        scannerType,
                        data);

                    if (!result)
                    {
                        return BadRequest(new { message = "Failed to import vulnerabilities" });
                    }
                }

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "VULNERABILITIES_IMPORTED",
                    $"Vulnerabilities imported from {scannerType}",
                    userId);

                return Ok(new { message = "Vulnerabilities imported successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error importing vulnerabilities");
                return StatusCode(500, new { message = "An error occurred while importing" });
            }
        }

        /// <summary>
        /// Generates vulnerability report
        /// </summary>
        [HttpGet("report")]
        [Authorize(Roles = "Admin,SecurityOfficer,VulnerabilityAnalyst,Auditor")]
        public async Task<IActionResult> GenerateReport(
            [FromQuery] DateTime startDate,
            [FromQuery] DateTime endDate)
        {
            try
            {
                var report = await _vulnerabilityService.GenerateVulnerabilityReportAsync(startDate, endDate);
                
                return File(report, "text/csv", $"vulnerability-report-{DateTime.UtcNow:yyyyMMdd}.csv");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating vulnerability report");
                return StatusCode(500, new { message = "An error occurred while generating report" });
            }
        }

        /// <summary>
        /// Syncs with CVE database
        /// </summary>
        [HttpPost("sync-cve")]
        [Authorize(Roles = "Admin,SecurityOfficer")]
        public async Task<IActionResult> SyncWithCveDatabase()
        {
            try
            {
                var result = await _vulnerabilityService.SyncWithCveDatabase();
                
                if (!result)
                {
                    return StatusCode(500, new { message = "Failed to sync with CVE database" });
                }

                var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
                await _auditService.LogAsync(
                    "CVE_DATABASE_SYNCED",
                    "CVE database synchronization completed",
                    userId);

                return Ok(new { message = "CVE database synchronized successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error syncing with CVE database");
                return StatusCode(500, new { message = "An error occurred while syncing" });
            }
        }

        #region Request/Response Models

        public class VulnerabilityDto
        {
            public Guid VulnerabilityId { get; set; }
            public string Title { get; set; }
            public string Description { get; set; }
            public string Severity { get; set; }
            public string Status { get; set; }
            public double? CVSSScore { get; set; }
            public double? RiskScore { get; set; }
            public DateTime DiscoveredAt { get; set; }
            public DateTime? ResolvedAt { get; set; }
            public int AffectedAssets { get; set; }
            public bool IsExploitable { get; set; }
        }

        public class CreateVulnerabilityRequest
        {
            public string Title { get; set; }
            public string Description { get; set; }
            public string Severity { get; set; }
            public string Type { get; set; }
            public double? CVSSScore { get; set; }
            public int AffectedAssets { get; set; }
            public bool IsExploitable { get; set; }
        }

        public class UpdateStatusRequest
        {
            public string Status { get; set; }
        }

        public class RemediationPlanRequest
        {
            public string Title { get; set; }
            public string Description { get; set; }
            public List<string> Steps { get; set; }
            public int EstimatedHours { get; set; }
            public string Priority { get; set; }
            public string AssignedTo { get; set; }
        }

        public class UpdateProgressRequest
        {
            public int ProgressPercentage { get; set; }
        }

        public class ScanRequest
        {
            public string ScanType { get; set; }
            public List<string> Targets { get; set; }
            public Dictionary<string, object> Options { get; set; }
        }

        public class ScheduleScanRequest
        {
            public string ScanType { get; set; }
            public List<string> Targets { get; set; }
            public string Schedule { get; set; }
        }

        public class DeployPatchRequest
        {
            public DateTime? ScheduledTime { get; set; }
            public List<string> Targets { get; set; }
        }

        public class RiskAnalysisRequest
        {
            public List<Guid> VulnerabilityIds { get; set; }
        }

        #endregion
    }
}