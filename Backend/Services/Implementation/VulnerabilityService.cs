using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using SabaFone.Backend.Data;
using SabaFone.Backend.Data.Vulnerabilities.Models;
using SabaFone.Backend.Exceptions;

namespace SabaFone.Backend.Services.Implementation
{
    public class VulnerabilityService : IVulnerabilityService
    {
        private readonly SsasDbContext _context;
        private readonly ILogger<VulnerabilityService> _logger;
        private readonly INotificationService _notificationService;
        private readonly IAuditService _auditService;

        public VulnerabilityService(
            SsasDbContext context,
            ILogger<VulnerabilityService> logger,
            INotificationService notificationService,
            IAuditService auditService)
        {
            _context = context;
            _logger = logger;
            _notificationService = notificationService;
            _auditService = auditService;
        }

        public async Task<Vulnerability> CreateVulnerabilityAsync(Vulnerability vulnerability)
        {
            try
            {
                vulnerability.VulnerabilityId = Guid.NewGuid();
                vulnerability.DiscoveredAt = DateTime.UtcNow;
                vulnerability.Status = "Open";
                vulnerability.CreatedAt = DateTime.UtcNow;

                _context.Vulnerabilities.Add(vulnerability);
                await _context.SaveChangesAsync();

                // Log audit
                await _auditService.LogAsync("VULNERABILITY_CREATED", 
                    $"New vulnerability created: {vulnerability.Title}");

                // Send notification for critical vulnerabilities
                if (vulnerability.Severity == "Critical")
                {
                    await _notificationService.SendCriticalVulnerabilityAlertAsync(vulnerability);
                }

                return vulnerability;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating vulnerability");
                throw;
            }
        }

        public async Task<Vulnerability> GetVulnerabilityAsync(Guid vulnerabilityId)
        {
            return await _context.Vulnerabilities
                .FirstOrDefaultAsync(v => v.VulnerabilityId == vulnerabilityId);
        }

        public async Task<List<Vulnerability>> GetActiveVulnerabilitiesAsync()
        {
            return await _context.Vulnerabilities
                .Where(v => v.Status != "Resolved" && v.Status != "Closed")
                .OrderByDescending(v => v.Severity)
                .ThenByDescending(v => v.DiscoveredAt)
                .ToListAsync();
        }

        public async Task<bool> UpdateVulnerabilityStatusAsync(Guid vulnerabilityId, string status)
        {
            var vulnerability = await GetVulnerabilityAsync(vulnerabilityId);
            if (vulnerability == null) return false;

            vulnerability.Status = status;
            vulnerability.UpdatedAt = DateTime.UtcNow;

            if (status == "Resolved")
            {
                vulnerability.ResolvedAt = DateTime.UtcNow;
            }

            await _context.SaveChangesAsync();

            await _auditService.LogAsync("VULNERABILITY_STATUS_UPDATED", 
                $"Vulnerability {vulnerabilityId} status changed to {status}");

            return true;
        }

        public async Task<double> CalculateRiskScoreAsync(Guid vulnerabilityId)
        {
            var vulnerability = await GetVulnerabilityAsync(vulnerabilityId);
            if (vulnerability == null) return 0;

            double riskScore = 0;

            // Base score from CVSS
            if (vulnerability.CVSSScore.HasValue)
            {
                riskScore = vulnerability.CVSSScore.Value;
            }
            else
            {
                // Calculate based on severity
                riskScore = vulnerability.Severity switch
                {
                    "Critical" => 9.5,
                    "High" => 7.5,
                    "Medium" => 5.0,
                    "Low" => 2.5,
                    _ => 1.0
                };
            }

            // Adjust for exploitability
            if (vulnerability.IsExploitable)
            {
                riskScore *= 1.2;
            }

            // Adjust for affected assets
            if (vulnerability.AffectedAssets > 10)
            {
                riskScore *= 1.1;
            }

            // Cap at 10
            riskScore = Math.Min(riskScore, 10);

            // Update vulnerability
            vulnerability.RiskScore = riskScore;
            await _context.SaveChangesAsync();

            return riskScore;
        }

        public async Task<string> AssessVulnerabilitySeverityAsync(Vulnerability vulnerability)
        {
            if (vulnerability.CVSSScore.HasValue)
            {
                return vulnerability.CVSSScore.Value switch
                {
                    >= 9.0 => "Critical",
                    >= 7.0 => "High",
                    >= 4.0 => "Medium",
                    >= 0.1 => "Low",
                    _ => "Info"
                };
            }

            // Assess based on other factors
            if (vulnerability.IsExploitable && vulnerability.AffectedAssets > 5)
                return "High";
            
            if (vulnerability.AffectedAssets > 10)
                return "Medium";

            return "Low";
        }

        public async Task<Dictionary<string, object>> PerformRiskAnalysisAsync(List<Guid> vulnerabilityIds)
        {
            var vulnerabilities = await _context.Vulnerabilities
                .Where(v => vulnerabilityIds.Contains(v.VulnerabilityId))
                .ToListAsync();

            var analysis = new Dictionary<string, object>
            {
                ["TotalVulnerabilities"] = vulnerabilities.Count,
                ["CriticalCount"] = vulnerabilities.Count(v => v.Severity == "Critical"),
                ["HighCount"] = vulnerabilities.Count(v => v.Severity == "High"),
                ["MediumCount"] = vulnerabilities.Count(v => v.Severity == "Medium"),
                ["LowCount"] = vulnerabilities.Count(v => v.Severity == "Low"),
                ["ExploitableCount"] = vulnerabilities.Count(v => v.IsExploitable),
                ["TotalAffectedAssets"] = vulnerabilities.Sum(v => v.AffectedAssets),
                ["AverageRiskScore"] = vulnerabilities.Average(v => v.RiskScore ?? 0),
                ["EstimatedRemediationHours"] = vulnerabilities.Sum(v => v.EstimatedRemediationHours ?? 0),
                ["RequiresImmediateAction"] = vulnerabilities.Any(v => v.Severity == "Critical" && v.IsExploitable)
            };

            return analysis;
        }

        public async Task<bool> CreateRemediationPlanAsync(Guid vulnerabilityId, Dictionary<string, object> plan)
        {
            var vulnerability = await GetVulnerabilityAsync(vulnerabilityId);
            if (vulnerability == null) return false;

            vulnerability.RemediationPlan = System.Text.Json.JsonSerializer.Serialize(plan);
            vulnerability.RemediationStatus = "Planned";
            vulnerability.UpdatedAt = DateTime.UtcNow;

            await _context.SaveChangesAsync();

            await _auditService.LogAsync("REMEDIATION_PLAN_CREATED", 
                $"Remediation plan created for vulnerability {vulnerabilityId}");

            return true;
        }

        public async Task<bool> TrackRemediationProgressAsync(Guid vulnerabilityId, int progressPercentage)
        {
            var vulnerability = await GetVulnerabilityAsync(vulnerabilityId);
            if (vulnerability == null) return false;

            vulnerability.RemediationProgress = progressPercentage;
            vulnerability.RemediationStatus = progressPercentage switch
            {
                100 => "Completed",
                > 0 => "In Progress",
                _ => "Not Started"
            };

            if (progressPercentage == 100)
            {
                vulnerability.Status = "Resolved";
                vulnerability.ResolvedAt = DateTime.UtcNow;
            }

            vulnerability.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();

            return true;
        }

        public async Task<List<object>> GetRemediationRecommendationsAsync(Guid vulnerabilityId)
        {
            var vulnerability = await GetVulnerabilityAsync(vulnerabilityId);
            if (vulnerability == null) return new List<object>();

            var recommendations = new List<object>();

            // Generate recommendations based on vulnerability type
            if (vulnerability.Type == "Software")
            {
                recommendations.Add(new
                {
                    Action = "Update Software",
                    Priority = "High",
                    Description = "Update to the latest version that addresses this vulnerability"
                });
            }

            if (vulnerability.Type == "Configuration")
            {
                recommendations.Add(new
                {
                    Action = "Review Configuration",
                    Priority = "Medium",
                    Description = "Review and update security configurations"
                });
            }

            if (vulnerability.IsExploitable)
            {
                recommendations.Add(new
                {
                    Action = "Apply Temporary Mitigation",
                    Priority = "Critical",
                    Description = "Apply temporary mitigations while permanent fix is being deployed"
                });
            }

            return recommendations;
        }

        public async Task<Dictionary<string, object>> GetVulnerabilityStatisticsAsync()
        {
            var stats = new Dictionary<string, object>
            {
                ["TotalVulnerabilities"] = await _context.Vulnerabilities.CountAsync(),
                ["ActiveVulnerabilities"] = await _context.Vulnerabilities.CountAsync(v => v.Status == "Open"),
                ["ResolvedVulnerabilities"] = await _context.Vulnerabilities.CountAsync(v => v.Status == "Resolved"),
                ["CriticalVulnerabilities"] = await _context.Vulnerabilities.CountAsync(v => v.Severity == "Critical" && v.Status == "Open"),
                ["HighVulnerabilities"] = await _context.Vulnerabilities.CountAsync(v => v.Severity == "High" && v.Status == "Open"),
                ["ExploitableVulnerabilities"] = await _context.Vulnerabilities.CountAsync(v => v.IsExploitable && v.Status == "Open"),
                ["AverageResolutionTime"] = await CalculateAverageResolutionTimeAsync(),
                ["VulnerabilitiesDiscoveredToday"] = await _context.Vulnerabilities.CountAsync(v => v.DiscoveredAt.Date == DateTime.UtcNow.Date)
            };

            return stats;
        }

        public async Task<byte[]> GenerateVulnerabilityReportAsync(DateTime startDate, DateTime endDate)
        {
            var vulnerabilities = await _context.Vulnerabilities
                .Where(v => v.DiscoveredAt >= startDate && v.DiscoveredAt <= endDate)
                .OrderByDescending(v => v.Severity)
                .ThenByDescending(v => v.DiscoveredAt)
                .ToListAsync();

            // Generate CSV report
            var csv = new StringBuilder();
            csv.AppendLine("ID,Title,Severity,Status,CVSS Score,Discovered,Resolved,Affected Assets");

            foreach (var vuln in vulnerabilities)
            {
                csv.AppendLine($"{vuln.VulnerabilityId},{vuln.Title},{vuln.Severity},{vuln.Status}," +
                    $"{vuln.CVSSScore},{vuln.DiscoveredAt:yyyy-MM-dd},{vuln.ResolvedAt:yyyy-MM-dd},{vuln.AffectedAssets}");
            }

            return Encoding.UTF8.GetBytes(csv.ToString());
        }

        public async Task<List<object>> GetVulnerabilityTrendsAsync(int monthsBack = 6)
        {
            var startDate = DateTime.UtcNow.AddMonths(-monthsBack);
            
            var trends = await _context.Vulnerabilities
                .Where(v => v.DiscoveredAt >= startDate)
                .GroupBy(v => new { v.DiscoveredAt.Year, v.DiscoveredAt.Month })
                .Select(g => new
                {
                    Year = g.Key.Year,
                    Month = g.Key.Month,
                    TotalDiscovered = g.Count(),
                    CriticalCount = g.Count(v => v.Severity == "Critical"),
                    HighCount = g.Count(v => v.Severity == "High"),
                    ResolvedCount = g.Count(v => v.Status == "Resolved")
                })
                .OrderBy(t => t.Year)
                .ThenBy(t => t.Month)
                .ToListAsync();

            return trends.Cast<object>().ToList();
        }

        public async Task<bool> ImportVulnerabilitiesFromScannerAsync(string scannerType, byte[] scanResults)
        {
            try
            {
                // Parse scan results based on scanner type
                var resultString = Encoding.UTF8.GetString(scanResults);
                
                // This is a simplified implementation
                // In production, parse based on actual scanner format (XML, JSON, etc.)
                var lines = resultString.Split('\n');
                var importedCount = 0;

                foreach (var line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
                {
                    // Parse vulnerability from line
                    var parts = line.Split(',');
                    if (parts.Length >= 3)
                    {
                        var vulnerability = new Vulnerability
                        {
                            VulnerabilityId = Guid.NewGuid(),
                            Title = parts[0],
                            Severity = parts[1],
                            Description = parts[2],
                            DiscoveredAt = DateTime.UtcNow,
                            DiscoveredBy = scannerType,
                            Status = "Open",
                            CreatedAt = DateTime.UtcNow
                        };

                        _context.Vulnerabilities.Add(vulnerability);
                        importedCount++;
                    }
                }

                if (importedCount > 0)
                {
                    await _context.SaveChangesAsync();
                    _logger.LogInformation($"Imported {importedCount} vulnerabilities from {scannerType}");
                }

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error importing vulnerabilities from {scannerType}");
                return false;
            }
        }

        public async Task<bool> SyncWithCveDatabase()
        {
            try
            {
                // In production, this would connect to NVD or other CVE databases
                _logger.LogInformation("CVE database sync initiated");
                
                // Simulate sync
                await Task.Delay(1000);
                
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error syncing with CVE database");
                return false;
            }
        }

        public async Task<List<object>> GetLatestCveEntriesAsync(int count = 100)
        {
            // In production, fetch from CVE database
            var cveEntries = new List<object>();
            
            for (int i = 0; i < Math.Min(count, 10); i++)
            {
                cveEntries.Add(new
                {
                    CVE = $"CVE-2024-{1000 + i}",
                    Description = $"Sample vulnerability {i}",
                    Severity = i % 4 == 0 ? "Critical" : i % 3 == 0 ? "High" : "Medium",
                    PublishedDate = DateTime.UtcNow.AddDays(-i)
                });
            }

            return await Task.FromResult(cveEntries);
        }

        private async Task<double> CalculateAverageResolutionTimeAsync()
        {
            var resolvedVulnerabilities = await _context.Vulnerabilities
                .Where(v => v.Status == "Resolved" && v.ResolvedAt.HasValue)
                .ToListAsync();

            if (!resolvedVulnerabilities.Any())
                return 0;

            var totalHours = resolvedVulnerabilities
                .Where(v => v.ResolvedAt.HasValue)
                .Sum(v => (v.ResolvedAt.Value - v.DiscoveredAt).TotalHours);

            return totalHours / resolvedVulnerabilities.Count;
        }
    }
}